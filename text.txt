


# Distributed URL Shortener with Supabase - Complete Roadmap

Let me rebuild this entire project plan using Supabase instead of traditional AWS database services. This will actually make your life MUCH easier!

## Why Supabase Changes Everything

**What is Supabase?**
Think of it as "Firebase but with a real PostgreSQL database." It gives you:
- A PostgreSQL database (hosted and managed for you)
- Built-in authentication (so you don't have to build user login from scratch)
- Real-time subscriptions (data updates live)
- Auto-generated REST API (you get APIs for free!)
- Built-in storage for files
- **Free tier that's very generous**

**What this means for you:**
- No need to manage RDS yourself
- No need to build authentication system
- Database comes with a nice dashboard
- Built-in API means less code to write

---

## The New Architecture with Supabase

### **Your Stack:**
- **Database:** Supabase (PostgreSQL)
- **Backend API:** Node.js/NestJS on AWS EC2 (or you could use Vercel/Railway for simpler deployment)
- **Cache:** Redis on AWS ElastiCache OR use Supabase's built-in caching
- **Queue:** AWS SQS (for analytics processing)
- **Background Jobs:** AWS Lambda
- **CDN:** CloudFront (for fast redirects globally)

---

## Database Design in Supabase

You'll create these tables directly in Supabase dashboard:

### **Table 1: profiles**
This links to Supabase authentication users.
- `id` (UUID, references auth.users)
- `email` (text)
- `created_at` (timestamp)

### **Table 2: urls**
Stores all your shortened URLs.
- `id` (UUID, primary key)
- `short_code` (text, unique, indexed - this is "a3X9k2")
- `long_url` (text - the original URL)
- `user_id` (UUID, references profiles.id)
- `custom_alias` (boolean - was this a custom code?)
- `password_hash` (text, nullable)
- `expires_at` (timestamp, nullable)
- `is_active` (boolean, default true)
- `created_at` (timestamp)
- `updated_at` (timestamp)

### **Table 3: clicks**
Stores every click on a short URL.
- `id` (UUID, primary key)
- `short_code` (text, references urls.short_code)
- `clicked_at` (timestamp)
- `ip_address` (text)
- `country` (text, nullable)
- `city` (text, nullable)
- `referrer` (text, nullable)
- `user_agent` (text)
- `device_type` (text - mobile/desktop/tablet)
- `browser` (text, nullable)


**Why this table?** If a URL has 1 million clicks, querying all of them every time someone wants stats is slow. This table stores daily summaries.

---

## Supabase Security: Row Level Security (RLS)

**What is RLS?**
Supabase has a powerful security feature where you set rules for who can read/write data. It's like having a bouncer at every table.

**Example rules you'll set up:**

**For the `urls` table:**
- Users can only see their own URLs
- Users can only delete/update their own URLs
- Anyone can read URL data (needed for redirects)

**For the `clicks` table:**
- Anyone can insert clicks (anonymous users clicking links)
- Only the URL owner can read click stats

**For the `url_stats_daily` table:**
- Only the URL owner can read stats
- System can write (via service role key)

**Why this matters:** You don't have to write permission checks in your code. The database handles it!

---

## The Complete Roadmap with Supabase

### **Phase 1: Setup & Basic Shortener (Week 1-2)**

#### **Week 1: Setup Everything**

**Day 1-2: Supabase Setup**
1. Create Supabase account (free tier)
2. Create a new project (choose region closest to you)
3. Save your project URL and API keys (you'll need these)
4. Create the four tables I mentioned above in the SQL Editor
5. Set up Row Level Security policies
6. Enable real-time on the `clicks` table (optional, but cool for live stats)

**Day 3-4: Local Development Setup**
1. Install Node.js and NestJS on your computer
2. Create a new NestJS project
3. Install Supabase JavaScript client library
4. Connect your app to Supabase using the API keys
5. Test connection by querying your empty tables

**Day 5-7: Build Core Routes**
1. Create the `POST /api/urls/shorten` endpoint
2. Create the `GET /:shortCode` redirect endpoint
3. Test both endpoints locally
4. Make sure short code generation works without collisions

#### **Week 2: Deploy Basic Version**

**Day 1-3: AWS EC2 Setup**
1. Launch a t2.micro EC2 instance (free tier)
2. Install Node.js on it
3. Set up security groups (allow HTTP/HTTPS traffic)
4. Get a domain name or use EC2's public DNS
5. Deploy your app to EC2

**Day 4-5: Add Authentication**
1. Enable Supabase Auth (it's built-in!)
2. Add sign up and login endpoints
3. Test user registration and login
4. Ensure URLs are tied to user accounts

**Day 6-7: Testing & Refinement**
1. Test creating URLs as different users
2. Test redirects work properly
3. Fix any bugs
4. Document your API endpoints

---

### **Phase 2: Analytics Tracking (Week 3)**

#### **What You'll Build:**

**Day 1-2: Basic Click Tracking**
1. Update the redirect endpoint to record clicks
2. When someone clicks a short URL, insert a row into `clicks` table
3. Extract basic info: timestamp, IP address, user agent
4. Test that clicks are being recorded

**Day 3-4: Parse User Agent**
1. Install a user agent parser library
2. Extract device type (mobile/desktop/tablet)
3. Extract browser name
4. Store this in the clicks table

**Day 5: IP Location Lookup**
1. Sign up for a free IP geolocation API (like ipapi.co - free tier: 1000 requests/day)
2. When recording a click, lookup IP location
3. Store country and city
4. Handle rate limits gracefully

**Day 6-7: Create Stats Endpoint**
1. Build `GET /api/urls/:shortCode/stats` endpoint
2. Query clicks table and aggregate data
3. Return: total clicks, clicks per day, top countries, device breakdown
4. Test with some fake click data

**The Simple Way (For Now):**
Just insert directly into the clicks table when someone clicks. Don't worry about queues yet - that's for later when you have more traffic.

---

### **Phase 3: Make It Fast with Caching (Week 4-5)**

#### **Week 4: Add Redis Caching**

**Why Redis?**
Supabase is fast, but if a URL gets 1000 clicks per second, you don't want to hit the database 1000 times. Redis can handle it.

**Day 1-2: Set Up Redis**
- Option A: AWS ElastiCache (free tier: cache.t2.micro)
- Option B: Use Upstash (free tier Redis, easier setup)
- Option C: Skip Redis initially, use in-memory caching in your app

**Day 3-5: Implement Caching Logic**
1. When redirect is requested, check Redis first
2. Cache structure: `shortCode` â†’ `{ longUrl, expiresAt, passwordHash }`
3. If not in Redis, query Supabase, then store in Redis
4. Set TTL (time to live) of 1 hour for cache entries
5. Test that caching speeds things up

**Day 6-7: Cache Invalidation**
1. When URL is updated, remove from Redis
2. When URL is deleted, remove from Redis
3. Test that updates work properly

#### **Week 5: Background Processing with Queues**

**The Problem:** Looking up IP locations takes time (can be 200-500ms). You don't want to make users wait.

**The Solution:** Queue system.

**Day 1-3: Set Up SQS Queue**
1. Create an SQS queue in AWS (free tier: 1M requests/month)
2. When someone clicks a URL, push a message to the queue instead of processing immediately
3. Message contains: short_code, ip_address, user_agent, timestamp, referrer
4. Redirect user immediately (they don't wait for processing)

**Day 4-5: Create Lambda Worker**
1. Create a Lambda function that processes queue messages
2. Lambda function reads message, looks up IP location, parses user agent
3. Lambda inserts fully processed click into Supabase
4. Test the full flow

**Day 6-7: Monitoring & Testing**
1. Add CloudWatch logs to see if Lambda is working
2. Test with burst of clicks
3. Verify all clicks are being processed
4. Check for any messages stuck in queue

---

### **Phase 4: Advanced Features (Week 6)**

#### **Password Protection**

**Day 1-2: Add Password Feature**
1. When creating URL, allow optional password
2. Hash password before storing (use bcrypt)
3. When someone visits protected URL, check if they've verified password
4. Use a temporary token (JWT) to remember they've verified
5. Create password verification endpoint

#### **Custom Aliases**

**Day 3-4: Allow Custom Short Codes**
1. Update shorten endpoint to accept custom alias
2. Validate alias: only letters, numbers, hyphens (no special characters)
3. Check if alias is already taken
4. If available, use it instead of generating random code
5. Test with various custom aliases

#### **URL Expiration**

**Day 5-6: Time-Based Expiration**
1. Add expiration logic to redirect endpoint
2. Check if `expires_at` is in the past
3. If expired, return 404 or "Link Expired" page
4. Optionally: Create a cleanup Lambda that runs daily to delete expired URLs

**Day 7: QR Code Generation**
1. Add QR code endpoint: `GET /api/urls/:shortCode/qr`
2. Use a QR code library to generate image
3. Return QR code as PNG
4. Test scanning QR codes with your phone

---

### **Phase 5: Production-Ready (Week 7-8)**

#### **Week 7: Optimize Performance**

**Day 1-2: Database Indexing**
1. In Supabase SQL editor, create indexes
2. Index on `urls.short_code` (most critical!)
3. Index on `clicks.short_code`
4. Index on `clicks.clicked_at` (for date range queries)
5. Test query performance improvement

**Day 3-4: Implement Daily Stats Aggregation**
1. Create a Lambda function that runs once daily (use CloudWatch Events)
2. Function queries all clicks from previous day
3. Aggregates data by short_code
4. Inserts summary into `url_stats_daily` table
5. This makes analytics queries much faster

**Day 5-6: Add CloudFront CDN**
1. Set up CloudFront distribution pointing to your EC2
2. Configure caching headers for redirect endpoint
3. Test that redirects are cached at edge locations
4. Verify redirects are faster from different locations

**Day 7: Connection Pooling**
1. Configure Supabase connection pooler (prevents too many database connections)
2. Use transaction mode for better performance
3. Test under load

#### **Week 8: Monitoring & Deployment**

**Day 1-2: Set Up Monitoring**
1. CloudWatch dashboards for EC2 CPU, memory
2. Supabase dashboard for database metrics
3. Create alerts: high error rate, high latency, database connections maxed out
4. Set up email notifications

**Day 3-4: Implement Health Checks**
1. Create `/health` endpoint
2. Checks: database connection, Redis connection, SQS connection
3. Returns status of each service
4. Use this for monitoring

**Day 5-7: CI/CD Pipeline**
1. Set up GitHub Actions workflow
2. On push to main branch: run tests
3. If tests pass: build Docker image
4. Deploy to EC2 automatically
5. Test the full deployment flow

---

## The API Routes (Detailed Logic)

### **1. POST /api/auth/signup**
**What happens:**
1. Receive email and password
2. Call Supabase Auth signup function
3. Supabase creates user in `auth.users` table
4. Your app creates corresponding row in `profiles` table
5. Return user data and session token

### **2. POST /api/auth/login**
**What happens:**
1. Receive email and password
2. Call Supabase Auth login function
3. Supabase verifies credentials
4. Return session token
5. Client includes this token in all future requests

### **3. POST /api/urls/shorten**
**Protected route (requires authentication)**

**Logic flow:**
1. Verify user is authenticated (check session token)
2. Receive: long_url, optional custom_alias, optional expiration, optional password
3. Validate long_url is a real URL
4. If custom_alias provided:
   - Check if it's available (query Supabase)
   - If taken, return error
   - Use custom_alias as short_code
5. If no custom_alias:
   - Generate random 6-character code (use base62: a-z, A-Z, 0-9)
   - Check if it exists (query Supabase)
   - If exists (collision!), generate another one
   - Repeat until unique code found
6. If password provided, hash it with bcrypt
7. Insert into Supabase `urls` table
8. Return short URL to user

**Important consideration:** In high-traffic scenarios, you might generate the same random code twice at the same time (race condition). Supabase handles this with unique constraints - the second insert will fail, and you can retry.

### **4. GET /:shortCode**
**The most critical route - must be FAST**

**Logic flow (with caching):**
1. Extract short_code from URL path
2. Check Redis cache: `GET shortCode`
3. If in cache:
   - Parse cached data
   - Check if expired
   - If not expired, go to step 8
4. If not in cache or expired:
   - Query Supabase: `SELECT * FROM urls WHERE short_code = ?`
   - If not found, return 404
   - If found, store in Redis with 1-hour TTL
5. Check if password protected:
   - If yes, check if user has verified password (check cookie/token)
   - If not verified, redirect to password page
6. Check if expired:
   - If `expires_at` is in past, return 404
7. Push click event to SQS queue (don't wait for response)
8. Perform HTTP 301 redirect to long_url
9. Done (entire process should take under 50ms)

**What goes in the queue message:**
```json
{
  "short_code": "a3X9k2",
  "timestamp": "2025-10-05T10:30:00Z",
  "ip_address": "203.0.113.45",
  "user_agent": "Mozilla/5.0...",
  "referrer": "https://twitter.com/..."
}
```

### **5. POST /api/urls/:shortCode/verify-password**
**For password-protected URLs**

**Logic flow:**
1. Receive: short_code, password_attempt
2. Query Supabase for URL
3. Get stored password_hash
4. Compare using bcrypt: `bcrypt.compare(password_attempt, password_hash)`
5. If match:
   - Generate temporary JWT token (valid for 1 hour)
   - Return token to client
   - Client stores in cookie
6. If no match:
   - Return error: "Incorrect password"

### **6. GET /api/urls/:shortCode/stats**
**Protected route (must own the URL)**

**Logic flow:**
1. Verify user is authenticated
2. Query Supabase: Get URL data
3. Verify user_id matches authenticated user
4. Query two sources:
   - `url_stats_daily` table for historical data (fast)
   - `clicks` table for today's data (slower)
5. Calculate statistics:
   - Total clicks (sum from both sources)
   - Clicks per day for last 30 days
   - Group by country, count
   - Group by device_type, count
   - Group by referrer, count
6. Return formatted JSON

**Optimization trick:** Since most stats don't need to be real-time, cache the stats response for 5 minutes.

### **7. GET /api/urls/user**
**List all URLs for authenticated user**

**Logic flow:**
1. Verify authentication
2. Get user_id from session
3. Query Supabase:
```sql
SELECT 
  u.short_code, 
  u.long_url, 
  u.created_at,
  COUNT(c.id) as total_clicks
FROM urls u
LEFT JOIN clicks c ON u.short_code = c.short_code
WHERE u.user_id = ?
GROUP BY u.id
ORDER BY u.created_at DESC
LIMIT 50 OFFSET ?
```
4. Return paginated results

### **8. PUT /api/urls/:shortCode**
**Update an existing URL**

**Logic flow:**
1. Verify authentication and ownership
2. Receive updated data: long_url, expires_at, password
3. Build update query based on what changed
4. Update in Supabase
5. **CRITICAL:** Delete from Redis cache
6. Return success

**Why delete from cache?** If you don't, people will still be redirected to the old URL until cache expires.

### **9. DELETE /api/urls/:shortCode**
**Delete a URL**

**Logic flow:**
1. Verify authentication and ownership
2. Delete from Supabase `urls` table
3. Delete from Redis cache
4. Optionally: delete associated clicks (or keep for archive)
5. Return success

---

## The Lambda Worker for Click Processing

**When it runs:** Triggered by SQS messages

**What it does:**

1. Receive message from SQS queue
2. Parse message to get: short_code, ip_address, user_agent, timestamp, referrer
3. Look up IP geolocation:
   - Call ipapi.co API: `GET http://ipapi.co/{ip}/json/`
   - Extract country and city
   - Handle errors (API down, rate limited, invalid IP)
4. Parse user agent:
   - Use library like `ua-parser-js`
   - Extract: device_type (mobile/desktop/tablet), browser name
5. Insert into Supabase `clicks` table:
   - short_code
   - clicked_at (from timestamp)
   - ip_address
   - country, city (from geolocation)
   - referrer
   - user_agent
   - device_type, browser (from parsing)
6. Delete message from SQS (acknowledges processing complete)
7. If any step fails, message stays in queue and retries later

**Error handling:**
- If IP lookup fails, still insert click with null country/city
- If parsing fails, still insert with null device_type
- Use try-catch around each step
- Log errors to CloudWatch for debugging

---

## The Daily Stats Aggregation Lambda

**When it runs:** Once per day at 2 AM (use CloudWatch Events cron)

**What it does:**

1. Get yesterday's date
2. Query Supabase for all clicks from yesterday
3. Group clicks by short_code
4. For each short_code, calculate:
   - Total clicks
   - Unique IPs (count distinct ip_address)
   - Top country (most frequent country)
5. Insert aggregated data into `url_stats_daily` table
6. Optionally: delete clicks older than 90 days (to save space)

**Why this helps:** Now when someone wants stats for a URL with 1 million clicks, you query 30 rows from `url_stats_daily` instead of 1 million rows from `clicks`.

---

## Working with Supabase: Key Concepts

### **Supabase Client in Your Code**

**Three ways to interact with Supabase:**

1. **Direct SQL queries** (for complex queries)
2. **Supabase client library** (easier, more abstraction)
3. **REST API** (auto-generated, good for simple CRUD)

**Example flow (conceptual, not actual code):**

When someone creates a short URL:
- Your NestJS controller receives request
- You call Supabase client to insert
- Supabase client handles authentication (checks if user has permission)
- Row Level Security checks if user can insert
- Data is inserted
- Supabase returns the inserted row
- You return success to user

### **Real-time Subscriptions (Optional but Cool)**

Supabase can push updates to your frontend in real-time.

**Use case:** Live click counter

When you enable real-time on the `clicks` table:
- User opens stats page for their URL
- Frontend subscribes to changes: "Tell me when new clicks happen for this short_code"
- When someone clicks the link, Lambda inserts into clicks table
- Supabase instantly pushes update to all subscribed clients
- Stats update in real-time without refreshing

### **Service Role vs Anon Key**

Supabase gives you two API keys:

**Anon key (public):**
- Used in frontend code
- Subject to Row Level Security
- Users can only access their own data

**Service role key (private):**
- Used in backend code
- Bypasses Row Level Security
- Full access to all data
- Keep this secret!

**When to use which:**
- Frontend: anon key
- Backend API: anon key (so RLS protects you)
- Lambda workers: service role key (needs full access)

---

## Cost Management on Free Tier

### **Supabase Free Tier:**
- 500MB database storage
- 2GB file storage
- 5GB bandwidth per month
- Unlimited API requests
- **This should last you a long time!**

### **What might push you over:**
- Storing millions of clicks (clicks table gets big)
- High bandwidth if lots of traffic
- Large files stored

### **How to stay free:**
- Archive old clicks to S3 after 90 days
- Use CloudFront to reduce bandwidth from Supabase
- Monitor your Supabase dashboard regularly

### **AWS Free Tier:**
- EC2: 750 hours/month (enough for 1 server running 24/7)
- Lambda: 1 million requests/month
- SQS: 1 million requests/month
- ElastiCache: 750 hours/month
- CloudFront: 50GB/month

**Total monthly cost if done right: $0 - $5**

---

## Testing Strategy

### **Week 1-2 Testing:**
- Manually test creating URLs
- Manually test redirects
- Use Postman to test API endpoints
- Create a few users, make sure isolation works

### **Week 3-4 Testing:**
- Generate fake click data (script that clicks links)
- Verify analytics are correct
- Test with burst of 100 clicks at once
- Check Lambda logs to verify processing

### **Week 5-6 Testing:**
- Load testing with a tool like Artillery or k6
- Test with 1000 requests per minute
- Monitor database CPU and memory
- Check cache hit rate

### **Week 7-8 Testing:**
- Full end-to-end testing of deployment
- Test rolling back a deployment
- Test monitoring alerts (intentionally break something)
- Security testing (try to access other users' URLs)

---

## Common Pitfalls to Avoid

### **1. Not handling the race condition in short code generation**
**Problem:** Two requests generate same code at same time.
**Solution:** Use database unique constraint. Let one succeed, one fail, retry the failed one.

### **2. Forgetting to clear cache on updates**
**Problem:** User updates URL, but redirects still go to old destination.
**Solution:** Always clear Redis cache when updating/deleting.

### **3. Not handling IP lookup failures gracefully**
**Problem:** IP API is down, Lambda crashes, clicks aren't recorded.
**Solution:** Use try-catch, insert click even if lookup fails.

### **4. Querying all clicks for stats**
**Problem:** URL has 1 million clicks, query takes 30 seconds.
**Solution:** Use the daily aggregation table for historical data.

### **5. Not monitoring costs**
**Problem:** CloudFront usage spikes, you get a $200 bill.
**Solution:** Set up AWS billing alerts at $5, $10, $20.

### **6. Exposing service role key**
**Problem:** Service key leaked, anyone can access all data.
**Solution:** Use environment variables, never commit keys to Git.

### **7. Not implementing rate limiting**
**Problem:** Someone spams your API, uses all your free tier.
**Solution:** Implement rate limiting (100 requests per hour per IP).

---

## Your Week-by-Week Checklist

### **Week 1:**
- [ ] Create Supabase account and project
- [ ] Set up database tables
- [ ] Configure Row Level Security
- [ ] Install NestJS locally
- [ ] Connect to Supabase
- [ ] Build and test shorten endpoint
- [ ] Build and test redirect endpoint

### **Week 2:**
- [ ] Launch EC2 instance
- [ ] Deploy app to EC2
- [ ] Set up Supabase Auth
- [ ] Add signup/login endpoints
- [ ] Test user authentication
- [ ] Ensure URL isolation (users can't see others' URLs)

### **Week 3:**
- [ ] Add click tracking to redirect endpoint
- [ ] Parse user agent
- [ ] Integrate IP geolocation API
- [ ] Build stats endpoint
- [ ] Test analytics with fake data

### **Week 4:**
- [ ] Set up Redis (ElastiCache or Upstash)
- [ ] Implement caching in redirect endpoint
- [ ] Test performance improvement
- [ ] Add cache invalidation

### **Week 5:**
- [ ] Create SQS queue
- [ ] Update redirect endpoint to push to queue
- [ ] Create Lambda function for click processing
- [ ] Test queue â†’ Lambda â†’ Supabase flow
- [ ] Monitor CloudWatch logs

### **Week 6:**
- [ ] Add password protection feature
- [ ] Add custom alias feature
- [ ] Add URL expiration
- [ ] Add QR code generation
- [ ] Test all new features

### **Week 7:**
- [ ] Add database indexes
- [ ] Create daily aggregation Lambda
- [ ] Set up CloudFront CDN
- [ ] Configure Supabase connection pooling
- [ ] Load test system

### **Week 8:**
- [ ] Set up CloudWatch monitoring
- [ ] Create health check endpoint
- [ ] Set up billing alerts
- [ ] Build CI/CD pipeline with GitHub Actions
- [ ] Test full deployment flow
- [ ] Document everything

---

## Resources You'll Need

### **Supabase:**
- Supabase documentation: docs.supabase.com
- Supabase JavaScript client docs
- RLS policy examples

### **AWS:**
- EC2 getting started guide
- Lambda documentation
- SQS documentation
- CloudFront setup guide

### **APIs:**
- ipapi.co (IP geolocation)
- ua-parser-js (user agent parsing)
- bcrypt (password hashing)

### **Development:**
- NestJS documentation
- PostgreSQL documentation
- Redis commands reference

---

## Final Tips

1. **Start simple, add complexity later** - Get basic shortening working before adding analytics
2. **Test everything locally first** - Don't debug in production
3. **Monitor costs daily** - Check AWS billing dashboard
4. **Use Supabase dashboard** - It's amazing for debugging database issues
5. **Log everything** - CloudWatch logs are your friend
6. **Don't optimize prematurely** - Cache only after you see it's slow
7. **Security first** - Always validate user input
8. **Document as you go** - Future you will thank present you

---

Does this Supabase-focused roadmap make sense? The main advantage is you're getting a managed database with auth built-in, so you can focus on building features rather than managing infrastructure. Would you like me to dive deeper into any specific week or component?